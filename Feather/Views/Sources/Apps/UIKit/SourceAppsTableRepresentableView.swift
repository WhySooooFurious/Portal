//
//  SourceAppsTableView.swift
//  Feather
//
//  Created by samara on 3.05.2025.
//

//
//  SourceAppsTableView.swift
//  Feather
//
//  Created by samara on 3.05.2025.
//

import SwiftUI
import AltSourceKit
import UIKit

struct SourceAppsTableRepresentableView: UIViewRepresentable {
    var sources: [ASRepository]
    @Binding var searchText: String
    @Binding var sortOption: SourceAppsView.SortOption
    @Binding var sortAscending: Bool
    var onSelect: (SourceAppsView.SourceAppRoute) -> Void

    func makeUIView(context: Context) -> UITableView {
        let tableView = UITableView(frame: .zero, style: .plain)
        tableView.delegate = context.coordinator
        tableView.dataSource = context.coordinator
        tableView.register(UITableViewCell.self, forCellReuseIdentifier: "AppCell")
        tableView.register(UITableViewHeaderFooterView.self, forHeaderFooterViewReuseIdentifier: "SectionHeader")

        tableView.separatorStyle = .none
        tableView.backgroundColor = .clear
        tableView.cellLayoutMarginsFollowReadableWidth = false
        tableView.rowHeight = UITableView.automaticDimension
        tableView.estimatedRowHeight = 80

        tableView.sectionHeaderHeight = UITableView.automaticDimension
        tableView.estimatedSectionHeaderHeight = 0
        if #available(iOS 15.0, *) {
            tableView.sectionHeaderTopPadding = 0
        }

        if #available(iOS 17, *) {
            tableView.allowsSelection = true
        } else {
            tableView.allowsSelection = false
        }

        tableView.alpha = 0
        UIView.transition(with: tableView, duration: 0.5, options: [.transitionCrossDissolve], animations: {
            tableView.alpha = 1
        })

        return tableView
    }

    func updateUIView(_ tableView: UITableView, context: Context) {
        context.coordinator.uiTableView = tableView

        let hasNewsHeader: Bool = {
            guard sources.count == 1 else { return false }
            guard let news = sources.first?.news else { return false }
            return !news.isEmpty
        }()

        if hasNewsHeader {
            let news = sources.first?.news ?? []
            let header = UIHostingController(rootView: SourceNewsView(news: news))
            header.view.translatesAutoresizingMaskIntoConstraints = true
            header.view.backgroundColor = .clear

            let fixedHeight: CGFloat = 161
            header.view.frame = CGRect(
                origin: .zero,
                size: CGSize(width: tableView.bounds.width, height: fixedHeight)
            )

            tableView.tableHeaderView = header.view
        } else {
            tableView.tableHeaderView = nil
        }

        let sourcesChanged = context.coordinator.sources != sources
        let searchChanged = context.coordinator.searchText != searchText
        let sortOptionChanged = context.coordinator.sortOption != sortOption
        let sortDirectionChanged = context.coordinator.sortAscending != sortAscending

        context.coordinator.sources = sources
        context.coordinator.searchText = searchText
        context.coordinator.sortOption = sortOption
        context.coordinator.sortAscending = sortAscending

        if sourcesChanged || searchChanged || sortOptionChanged || sortDirectionChanged {
            context.coordinator.invalidateCache()
        }
    }

    func makeCoordinator() -> Coordinator {
        Coordinator(
            sources: sources,
            searchText: searchText,
            sortOption: sortOption,
            sortAscending: sortAscending,
            onSelect: onSelect
        )
    }
}

extension SourceAppsTableRepresentableView {
    class Coordinator: NSObject, UITableViewDataSource, UITableViewDelegate {
        var sources: [ASRepository]
        var searchText: String
        var sortOption: SourceAppsView.SortOption
        var sortAscending: Bool
        let onSelect: (SourceAppsView.SourceAppRoute) -> Void

        private var _groupedAppsByNameFirstLetter: [String: [(source: ASRepository, app: ASRepository.App)]] = [:]
        private var _groupedAppsByDate: [String: [(source: ASRepository, app: ASRepository.App)]] = [:]
        private var _sortedSectionTitles: [String] = []

        private var _cachedSortedApps: [(source: ASRepository, app: ASRepository.App)] = []
        weak var uiTableView: UITableView?

        private var _expandedAppID: String?

        private var _allAppsWithSource: [(source: ASRepository, app: ASRepository.App)] {
            sources.flatMap { source in source.apps.map { (source: source, app: $0) } }
        }

        private var _sortedApps: [(source: ASRepository, app: ASRepository.App)] {
            if !_cachedSortedApps.isEmpty { return _cachedSortedApps }
            _cachedSortedApps = _calculateSortedApps()
            return _cachedSortedApps
        }

        init(
            sources: [ASRepository],
            searchText: String,
            sortOption: SourceAppsView.SortOption,
            sortAscending: Bool,
            onSelect: @escaping (SourceAppsView.SourceAppRoute) -> Void
        ) {
            self.sources = sources
            self.searchText = searchText
            self.sortOption = sortOption
            self.sortAscending = sortAscending
            self.onSelect = onSelect
            super.init()

            if sortOption != .default {
                invalidateCache()
            }
        }

        private func _calculateSortedApps() -> [(source: ASRepository, app: ASRepository.App)] {
            let filtered = _allAppsWithSource.filter {
                searchText.isEmpty ||
                ($0.app.name?.localizedCaseInsensitiveContains(searchText) ?? false) ||
                ($0.app.description?.localizedCaseInsensitiveContains(searchText) ?? false) ||
                ($0.app.subtitle?.localizedCaseInsensitiveContains(searchText) ?? false) ||
                ($0.app.localizedDescription?.localizedCaseInsensitiveContains(searchText) ?? false)
            }

            switch sortOption {
            case .default:
                _groupedAppsByDate = [:]
                _groupedAppsByNameFirstLetter = [:]
                _sortedSectionTitles = []
                return sortAscending ? filtered : filtered.reversed()

            case .date:
                let sorted = filtered.sorted {
                    let d1 = $0.app.currentDate?.date ?? .distantPast
                    let d2 = $1.app.currentDate?.date ?? .distantPast
                    return sortAscending ? (d1 < d2) : (d1 > d2)
                }

                let formatter = DateFormatter()
                formatter.dateFormat = "MMMM d, yyyy"

                let grouped = Dictionary(grouping: sorted) {
                    $0.app.currentDate?.date.stripTime() ?? .distantPast
                }

                let sortedDates = grouped.keys.sorted(by: { sortAscending ? $0 > $1 : $0 < $1 })

                _groupedAppsByDate = grouped.reduce(into: [:]) { result, pair in
                    let key = formatter.string(from: pair.key)
                    result[key] = pair.value
                }

                _sortedSectionTitles = sortedDates.map { formatter.string(from: $0) }
                return sorted

            case .name:
                let sorted = filtered.sorted {
                    let n1 = $0.app.name ?? ""
                    let n2 = $1.app.name ?? ""
                    let comparison = n1.localizedCaseInsensitiveCompare(n2) == .orderedAscending
                    return sortAscending ? comparison : !comparison
                }

                _groupedAppsByNameFirstLetter = Dictionary(grouping: sorted) {
                    let first = $0.app.name?.trimmingCharacters(in: .whitespacesAndNewlines).first?.uppercased() ?? "#"
                    return first.range(of: "[A-Z]", options: .regularExpression) != nil ? first : "#"
                }

                _sortedSectionTitles = _groupedAppsByNameFirstLetter.keys.sorted(by: {
                    if $0 == "#" { return false }
                    if $1 == "#" { return true }
                    return sortAscending ? $0 < $1 : $0 > $1
                })

                return sorted
            }
        }

        func invalidateCache() {
            _cachedSortedApps = _calculateSortedApps()
            if let expanded = _expandedAppID, indexPath(forAppID: expanded) == nil {
                _expandedAppID = nil
            }
            if let tableView = uiTableView {
                UIView.transition(with: tableView, duration: 0.3, options: [.transitionCrossDissolve], animations: {
                    tableView.reloadData()
                })
            }
        }

        func numberOfSections(in tableView: UITableView) -> Int {
            switch sortOption {
            case .default: 1
            case .name, .date: _sortedSectionTitles.count
            }
        }

        func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
            switch sortOption {
            case .default: _sortedApps.count
            case .name: _groupedAppsByNameFirstLetter[_sortedSectionTitles[section]]?.count ?? 0
            case .date: _groupedAppsByDate[_sortedSectionTitles[section]]?.count ?? 0
            }
        }

        func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
            let cell = tableView.dequeueReusableCell(withIdentifier: "AppCell", for: indexPath)

            let entry: (source: ASRepository, app: ASRepository.App)
            switch sortOption {
            case .default: entry = _sortedApps[indexPath.row]
            case .name: entry = _groupedAppsByNameFirstLetter[_sortedSectionTitles[indexPath.section]]?[indexPath.row] ?? _sortedApps[indexPath.row]
            case .date: entry = _groupedAppsByDate[_sortedSectionTitles[indexPath.section]]?[indexPath.row] ?? _sortedApps[indexPath.row]
            }

            let appID = entry.app.currentUniqueId
            let isExpanded = (_expandedAppID == appID)
            let showBadge = sources.count > 1

            cell.selectionStyle = .none
            cell.backgroundConfiguration = UIBackgroundConfiguration.clear()
            cell.backgroundColor = .clear
            cell.contentView.backgroundColor = .clear
            cell.selectedBackgroundView = UIView()
            cell.layer.borderWidth = 0
            cell.contentView.layer.borderWidth = 0

            cell.contentConfiguration = UIHostingConfiguration {
                CollapsibleAppRow(
                    source: entry.source,
                    app: entry.app,
                    isExpanded: isExpanded,
                    showSourceBadge: showBadge,
                    onToggle: { [weak self] in
                        self?.toggleExpanded(appID: appID)
                    },
                    onOpen: { [weak self] in
                        guard let self else { return }
                        self.onSelect(SourceAppsView.SourceAppRoute(source: entry.source, app: entry.app))
                    }
                )
            }

            return cell
        }

        func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
            if #available(iOS 17, *) {
                tableView.deselectRow(at: indexPath, animated: true)

                let entry: (source: ASRepository, app: ASRepository.App)
                switch sortOption {
                case .default: entry = _sortedApps[indexPath.row]
                case .name: entry = _groupedAppsByNameFirstLetter[_sortedSectionTitles[indexPath.section]]?[indexPath.row] ?? _sortedApps[indexPath.row]
                case .date: entry = _groupedAppsByDate[_sortedSectionTitles[indexPath.section]]?[indexPath.row] ?? _sortedApps[indexPath.row]
                }

                onSelect(SourceAppsView.SourceAppRoute(source: entry.source, app: entry.app))
            }
        }

        func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {
            if sortOption == .default { return nil }

            let headerView = tableView.dequeueReusableHeaderFooterView(withIdentifier: "SectionHeader")
            let title = _sortedSectionTitles[section]

            headerView?.contentConfiguration = UIHostingConfiguration {
                HStack {
                    Text(verbatim: title)
                    Spacer()
                }
                .font(.headline)
                .padding(.vertical, 2)
            }

            return headerView
        }

        func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {
            sortOption == .default ? .leastNonzeroMagnitude : UITableView.automaticDimension
        }

        func tableView(_ tableView: UITableView, estimatedHeightForHeaderInSection section: Int) -> CGFloat {
            sortOption == .default ? 0 : 28
        }

        func sectionIndexTitles(for tableView: UITableView) -> [String]? {
            sortOption == .name ? _sortedSectionTitles : nil
        }

        func tableView(_ tableView: UITableView, sectionForSectionIndexTitle title: String, at index: Int) -> Int {
            _sortedSectionTitles.firstIndex(of: title) ?? 0
        }

        private func toggleExpanded(appID: String) {
            let previous = _expandedAppID
            _expandedAppID = (previous == appID) ? nil : appID

            guard let tableView = uiTableView else { return }

            var toReload: [IndexPath] = []
            if let previous, let ip = indexPath(forAppID: previous) { toReload.append(ip) }
            if let ip = indexPath(forAppID: appID) { toReload.append(ip) }

            if !toReload.isEmpty {
                tableView.reloadRows(at: Array(Set(toReload)), with: .automatic)
            } else {
                tableView.reloadData()
            }
        }

        private func indexPath(forAppID id: String) -> IndexPath? {
            switch sortOption {
            case .default:
                if let row = _sortedApps.firstIndex(where: { $0.app.currentUniqueId == id }) {
                    return IndexPath(row: row, section: 0)
                }
                return nil

            case .name:
                for (section, title) in _sortedSectionTitles.enumerated() {
                    if let arr = _groupedAppsByNameFirstLetter[title],
                       let row = arr.firstIndex(where: { $0.app.currentUniqueId == id }) {
                        return IndexPath(row: row, section: section)
                    }
                }
                return nil

            case .date:
                for (section, title) in _sortedSectionTitles.enumerated() {
                    if let arr = _groupedAppsByDate[title],
                       let row = arr.firstIndex(where: { $0.app.currentUniqueId == id }) {
                        return IndexPath(row: row, section: section)
                    }
                }
                return nil
            }
        }

        func tableView(_ tableView: UITableView, contextMenuConfigurationForRowAt indexPath: IndexPath, point: CGPoint) -> UIContextMenuConfiguration? {
            let entry: (source: ASRepository, app: ASRepository.App)
            switch sortOption {
            case .default: entry = _sortedApps[indexPath.row]
            case .name: entry = _groupedAppsByNameFirstLetter[_sortedSectionTitles[indexPath.section]]?[indexPath.row] ?? _sortedApps[indexPath.row]
            case .date: entry = _groupedAppsByDate[_sortedSectionTitles[indexPath.section]]?[indexPath.row] ?? _sortedApps[indexPath.row]
            }

            return UIContextMenuConfiguration(identifier: nil, previewProvider: nil) { _ in
                let versionsMenu = UIMenu(
                    title: .localized("Copy Download URLs"),
                    image: UIImage(systemName: "list.bullet"),
                    children: self._contextActions(
                        for: entry.app,
                        with: { version in UIPasteboard.general.string = version?.absoluteString },
                        image: UIImage(systemName: "doc.on.clipboard")
                    )
                )

                let downloadsMenu = UIMenu(
                    title: .localized("Previous Versions"),
                    image: UIImage(systemName: "square.and.arrow.down.on.square"),
                    children: self._contextActions(
                        for: entry.app,
                        with: { version in
                            if let url = version {
                                _ = DownloadManager.shared.startDownload(from: url, id: entry.app.currentUniqueId)
                            }
                        },
                        image: UIImage(systemName: "arrow.down")
                    )
                )

                return UIMenu(children: [downloadsMenu, versionsMenu])
            }
        }

        private func _contextActions(
            for app: ASRepository.App,
            with action: @escaping (URL?) -> Void,
            image: UIImage?
        ) -> [UIAction] {
            if let versions = app.versions, !versions.isEmpty {
                return versions.map { version in
                    UIAction(title: version.version, image: image) { _ in
                        action(version.downloadURL)
                    }
                }
            } else {
                return [
                    UIAction(title: app.currentVersion ?? "", image: image) { _ in
                        action(app.currentDownloadUrl)
                    }
                ]
            }
        }
    }
}

private struct CollapsibleAppRow: View {
    let source: ASRepository
    let app: ASRepository.App
    let isExpanded: Bool
    let showSourceBadge: Bool
    let onToggle: () -> Void
    let onOpen: () -> Void
    
    private var descriptionText: String {
        (app.localizedDescription ?? app.description ?? app.subtitle ?? "")
            .trimmingCharacters(in: .whitespacesAndNewlines)
    }
    
    var body: some View {
        VStack(alignment: .leading, spacing: 6) {
            SourceAppsCellView(source: source, app: app, showSourceBadge: showSourceBadge)
            
            if !descriptionText.isEmpty {
                Text(descriptionText)
                    .font(.subheadline)
                    .foregroundStyle(.secondary)
                    .lineLimit(isExpanded ? nil : 3)
                    .contentShape(Rectangle())
                    .onTapGesture { onToggle() }
            }
        }
        .padding(.vertical, 8)
        .contentShape(Rectangle())
        .onTapGesture { onOpen() }
    }
}
